// Unity Meet - Database Schema
// PostgreSQL with Prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ==================== USER & AUTH ====================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  name          String
  password      String    // bcrypt hashed
  avatar        String?
  role          UserRole  @default(AGENT)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  sessions       Session[]
  hostedMeetings Meeting[]       @relation("host")
  participations MeetingParticipant[]
  recordings     Recording[]

  @@index([email])
}

enum UserRole {
  ADMIN
  STAFF
  AGENT
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ==================== MEETINGS ====================

model Meeting {
  id             String         @id @default(cuid())
  roomId         String         @unique // JaaS room identifier
  title          String
  description    String?
  type           MeetingType    @default(INSTANT)
  status         MeetingStatus  @default(PENDING)

  // Scheduling
  scheduledStart DateTime?
  scheduledEnd   DateTime?
  timezone       String         @default("America/New_York")

  // Settings
  maxParticipants Int           @default(50)
  enableWaitingRoom Boolean     @default(false)
  enableRecording   Boolean     @default(false)
  isPublic          Boolean     @default(true) // Guest access allowed
  password          String?     // Optional room password

  // Timestamps
  startedAt      DateTime?
  endedAt        DateTime?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  // Relations
  hostId         String
  host           User           @relation("host", fields: [hostId], references: [id])
  participants   MeetingParticipant[]
  recordings     Recording[]
  invitations    MeetingInvitation[]
  waitingRoom    WaitingRoomEntry[]

  // Webinar specific
  webinarSettings WebinarSettings?
  polls           Poll[]
  questions       Question[]

  // AI Intelligence
  aiSummary       MeetingSummary?

  @@index([hostId])
  @@index([roomId])
  @@index([status])
  @@index([scheduledStart])
}

enum MeetingType {
  INSTANT
  SCHEDULED
  WEBINAR
}

enum MeetingStatus {
  PENDING
  LIVE
  ENDED
  CANCELLED
}

model MeetingParticipant {
  id        String          @id @default(cuid())
  meetingId String
  meeting   Meeting         @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  // For authenticated users
  userId    String?
  user      User?           @relation(fields: [userId], references: [id])

  // For guest participants
  guestName String?
  guestEmail String?

  role      ParticipantRole @default(PARTICIPANT)
  joinedAt  DateTime?
  leftAt    DateTime?
  duration  Int?            // in seconds

  @@unique([meetingId, userId])
  @@unique([meetingId, guestEmail])
  @@index([meetingId])
  @@index([userId])
}

enum ParticipantRole {
  HOST
  CO_HOST
  PANELIST    // For webinars
  PARTICIPANT
  VIEWER      // View-only for webinars
}

model WaitingRoomEntry {
  id        String   @id @default(cuid())
  meetingId String
  meeting   Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  name      String
  email     String?
  status    WaitingRoomStatus @default(WAITING)
  requestedAt DateTime @default(now())
  processedAt DateTime?
  processedBy String?  // userId who admitted/rejected

  @@index([meetingId, status])
}

enum WaitingRoomStatus {
  WAITING
  ADMITTED
  REJECTED
}

// ==================== WEBINAR FEATURES ====================

model WebinarSettings {
  id                  String  @id @default(cuid())
  meetingId           String  @unique
  meeting             Meeting @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  enableQA            Boolean @default(true)
  enablePolls         Boolean @default(true)
  enableChat          Boolean @default(true)
  enableHandRaise     Boolean @default(true)
  autoAdmit           Boolean @default(false)
  registrationRequired Boolean @default(false)
}

model Poll {
  id        String   @id @default(cuid())
  meetingId String
  meeting   Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  question  String
  options   Json     // [{id: string, text: string}]
  isActive  Boolean  @default(false)
  results   Json?    // {optionId: count}
  createdAt DateTime @default(now())
  closedAt  DateTime?

  responses PollResponse[]

  @@index([meetingId])
}

model PollResponse {
  id         String   @id @default(cuid())
  pollId     String
  poll       Poll     @relation(fields: [pollId], references: [id], onDelete: Cascade)

  optionId   String
  responderId String? // null for guests
  responderName String?
  createdAt  DateTime @default(now())

  @@unique([pollId, responderId])
}

model Question {
  id          String   @id @default(cuid())
  meetingId   String
  meeting     Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  content     String
  askerName   String
  askerId     String?  // null for guests
  isAnonymous Boolean  @default(false)
  isAnswered  Boolean  @default(false)
  upvotes     Int      @default(0)
  createdAt   DateTime @default(now())
  answeredAt  DateTime?

  @@index([meetingId, isAnswered])
}

// ==================== RECORDINGS ====================

model Recording {
  id          String   @id @default(cuid())
  meetingId   String
  meeting     Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  userId      String   // who initiated the recording
  user        User     @relation(fields: [userId], references: [id])

  filename    String
  url         String   // DO Spaces URL
  size        BigInt   // bytes
  duration    Int      // seconds
  status      RecordingStatus @default(PROCESSING)
  createdAt   DateTime @default(now())
  processedAt DateTime?

  @@index([meetingId])
  @@index([userId])
}

enum RecordingStatus {
  PROCESSING
  READY
  FAILED
}

// ==================== INVITATIONS & REMINDERS ====================

model MeetingInvitation {
  id        String           @id @default(cuid())
  meetingId String
  meeting   Meeting          @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  email     String
  name      String?
  status    InvitationStatus @default(PENDING)
  token     String           @unique @default(cuid()) // For tracking opens
  sentAt    DateTime?
  openedAt  DateTime?
  respondedAt DateTime?
  createdAt DateTime         @default(now())

  @@unique([meetingId, email])
  @@index([meetingId])
  @@index([token])
}

enum InvitationStatus {
  PENDING
  SENT
  OPENED
  ACCEPTED
  DECLINED
}

model ScheduledReminder {
  id        String   @id @default(cuid())
  meetingId String
  type      ReminderType
  scheduledFor DateTime
  sentAt    DateTime?

  @@index([scheduledFor, sentAt])
}

enum ReminderType {
  ONE_DAY
  ONE_HOUR
  FIFTEEN_MIN
}

// ==================== AI MEETING INTELLIGENCE ====================

model MeetingSummary {
  id          String   @id @default(cuid())
  meetingId   String   @unique
  meeting     Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  // Transcript data
  transcript     String?  @db.Text // Raw transcript text
  transcriptJson Json?    // Structured transcript [{speaker, text, timestamp}]

  // AI-generated content
  title          String?
  summary        String?  @db.Text
  keyPoints      Json?    // string[]
  language       String   @default("es")

  // Analysis
  topics         Json?    // [{name, duration, percentage}]
  sentiment      String?  // positive, neutral, negative
  participation  Json?    // [{participant, speakingTime, percentage}]
  suggestions    Json?    // string[]

  // Action items
  actionItems    Json?    // [{task, assignee, dueDate, priority, context}]

  // Follow-up email
  followUpEmail  Json?    // {subject, body}

  // Status
  status         AISummaryStatus @default(PENDING)
  errorMessage   String?

  // Timestamps
  generatedAt    DateTime?
  emailSentAt    DateTime?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([meetingId])
  @@index([status])
}

enum AISummaryStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  EMAIL_SENT
}
